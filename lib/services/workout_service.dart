import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/workout.dart';
import '../models/workout_folder.dart';
import '../models/workout_exercise.dart';
import '../models/workout_set.dart';
import '../models/exercise.dart';

class WorkoutService {
  static final WorkoutService _instance = WorkoutService._internal();
  factory WorkoutService() => _instance;
  WorkoutService._internal();
  
  static WorkoutService get instance => _instance;

  List<Workout> _workouts = [];
  List<WorkoutFolder> _folders = [];

  List<Workout> get workouts => _workouts;
  List<WorkoutFolder> get folders => _folders;

  static const String _workoutsKey = 'workouts';
  static const String _foldersKey = 'folders';

  Future<void> loadData() async {
    final prefs = await SharedPreferences.getInstance();
    
    // Load workouts
    final workoutsJson = prefs.getString(_workoutsKey);
    if (workoutsJson != null) {
      final List<dynamic> workoutsList = json.decode(workoutsJson);
      _workouts = workoutsList.map((w) => Workout.fromMap(w)).toList();
    }
    
    // Load folders
    final foldersJson = prefs.getString(_foldersKey);
    if (foldersJson != null) {
      final List<dynamic> foldersList = json.decode(foldersJson);
      _folders = foldersList.map((f) => WorkoutFolder.fromMap(f)).toList();
    }
  }

  Future<void> saveData() async {
    final prefs = await SharedPreferences.getInstance();
    
    // Save workouts
    final workoutsJson = json.encode(_workouts.map((w) => w.toMap()).toList());
    await prefs.setString(_workoutsKey, workoutsJson);
    
    // Save folders
    final foldersJson = json.encode(_folders.map((f) => f.toMap()).toList());
    await prefs.setString(_foldersKey, foldersJson);
  }

  // Folder operations
  Future<WorkoutFolder> createFolder(String name) async {
    final folder = WorkoutFolder(
      // id is now auto-generated by Uuid if not provided
      name: name,
      // orderIndex can be set if needed, defaults to null
    );
    
    _folders.add(folder);
    await saveData();
    return folder;
  }

  Future<void> updateFolder(WorkoutFolder folder) async {
    final index = _folders.indexWhere((f) => f.id == folder.id);
    if (index != -1) {
      // folder.copyWith() no longer has updatedAt.
      // If an updatedAt logic is needed for SharedPreferences, it would be handled differently.
      // For now, just assign the folder, assuming its properties (like name, orderIndex) are already updated.
      _folders[index] = folder; 
      await saveData();
    }
  }

  Future<void> deleteFolder(String folderId) async {
    // Move workouts out of folder before deleting
    for (int i = 0; i < _workouts.length; i++) {
      if (_workouts[i].folderId == folderId) {
        _workouts[i] = _workouts[i].copyWith(folderId: null);
      }
    }
    
    _folders.removeWhere((f) => f.id == folderId);
    await saveData();
  }

  // Workout operations
  Future<Workout> createWorkout(String name, {String? folderId}) async {
    final workout = Workout(
      // id is now auto-generated by Uuid if not provided in the model
      name: name,
      exercises: [], // Defaulting to empty, will be managed by WorkoutExercises table
      folderId: folderId,
      // createdAt and updatedAt are removed
      // New fields like description, notes, lastUsed, orderIndex can be added here if needed
    );
    
    _workouts.add(workout);
    await saveData();
    return workout;
  }

  Future<void> updateWorkout(Workout workout) async {
    final index = _workouts.indexWhere((w) => w.id == workout.id);
    if (index != -1) {
      // workout.copyWith() no longer has updatedAt.
      // The Workout model's properties (name, folderId, exercises, etc.) should be updated before calling this.
      // If a lastUsed logic is needed for SharedPreferences, it would be:
      // _workouts[index] = workout.copyWith(lastUsed: DateTime.now().toIso8601String());
      // For now, just assign the workout, assuming its properties are already updated.
      _workouts[index] = workout;
      await saveData();
    }
  }

  Future<void> deleteWorkout(String workoutId) async {
    _workouts.removeWhere((w) => w.id == workoutId);
    await saveData();
  }

  Future<void> moveWorkoutToFolder(String workoutId, String? folderId) async {
    final index = _workouts.indexWhere((w) => w.id == workoutId);
    if (index != -1) {
      _workouts[index] = _workouts[index].copyWith(
        folderId: folderId,
        // updatedAt: DateTime.now(), // Removed
        // lastUsed: DateTime.now().toIso8601String(), // Could be added here
      );
      await saveData();
    }
  }

  Future<void> reorderWorkoutsInFolder(String? folderId, int oldIndex, int newIndex) async {
    final workoutsInFolder = getWorkoutsInFolder(folderId);
    if (oldIndex < 0 || oldIndex >= workoutsInFolder.length || 
        newIndex < 0 || newIndex >= workoutsInFolder.length) {
      return;
    }

    // Remove the workout from the old position
    final workout = workoutsInFolder.removeAt(oldIndex);
    // Insert it at the new position
    workoutsInFolder.insert(newIndex, workout);

    // Update the main workouts list with the new order
    final otherWorkouts = _workouts.where((w) => w.folderId != folderId).toList();
    _workouts = [...otherWorkouts, ...workoutsInFolder];
    
    await saveData();
  }

  // Exercise operations within workout
  Future<void> addExerciseToWorkout(String workoutId, Exercise exerciseDetail) async { // Parameter renamed for clarity
    final workoutIndex = _workouts.indexWhere((w) => w.id == workoutId);
    if (workoutIndex != -1) {
      // Create a workout exercise. Its ID will be auto-generated.
      // A default set will also be created. Its ID will be auto-generated.
      // The WorkoutSet needs workoutExerciseId, which isn't known until WorkoutExercise is made.
      // This part of the logic will be more complex with SQLite and might be better handled
      // by creating WorkoutExercise first, then WorkoutSet.
      // For now, to fix compilation with SharedPreferences structure:
      
      final tempWorkoutExerciseId = DateTime.now().millisecondsSinceEpoch.toString() + "_ex";

      final defaultSet = WorkoutSet(
        // id: DateTime.now().millisecondsSinceEpoch.toString(), // ID is auto-generated
        workoutExerciseId: tempWorkoutExerciseId, // Temporary link
        setNumber: 1,
        targetReps: 10,
        targetWeight: 0.0,
      );
      
      final workoutExercise = WorkoutExercise(
        id: tempWorkoutExerciseId, // Use the temp ID
        workoutId: workoutId,
        exerciseSlug: exerciseDetail.slug, // Use slug from Exercise object
        exerciseDetail: exerciseDetail, // Keep for in-memory model if needed by current logic
        sets: [defaultSet],
      );
      // Adjust WorkoutSet's workoutExerciseId if it was truly temporary and WorkoutExercise.id is different
      // For Uuid, workoutExercise.id will be different.
      // defaultSet.workoutExerciseId = workoutExercise.id; // This line won't work as workoutExerciseId is final.
      // This indicates a deeper refactor is needed for how sets are associated when using SQLite.
      // For now, the above structure is a temporary bridge.

      final updatedExercises = List<WorkoutExercise>.from(_workouts[workoutIndex].exercises);
      updatedExercises.add(workoutExercise);
      
      _workouts[workoutIndex] = _workouts[workoutIndex].copyWith(
        exercises: updatedExercises,
        // updatedAt: DateTime.now(), // Removed
        // lastUsed: DateTime.now().toIso8601String(), // Could be added here
      );
      
      await saveData();
    }
  }

  Future<void> removeExerciseFromWorkout(String workoutId, String exerciseId) async {
    final workoutIndex = _workouts.indexWhere((w) => w.id == workoutId);
    if (workoutIndex != -1) {
      final updatedExercises = _workouts[workoutIndex].exercises
          .where((e) => e.id != exerciseId)
          .toList();
      
      _workouts[workoutIndex] = _workouts[workoutIndex].copyWith(
        exercises: updatedExercises,
        // updatedAt: DateTime.now(), // Removed
        // lastUsed: DateTime.now().toIso8601String(), // Could be added here
      );
      
      await saveData();
    }
  }

  Future<void> updateWorkoutExercise(String workoutId, WorkoutExercise exercise) async {
    final workoutIndex = _workouts.indexWhere((w) => w.id == workoutId);
    if (workoutIndex != -1) {
      final updatedExercises = _workouts[workoutIndex].exercises.map((e) {
        return e.id == exercise.id ? exercise : e;
      }).toList();
      
      _workouts[workoutIndex] = _workouts[workoutIndex].copyWith(
        exercises: updatedExercises,
        // updatedAt: DateTime.now(), // Removed
        // lastUsed: DateTime.now().toIso8601String(), // Could be added here
      );
      
      await saveData();
    }
  }

  // Set operations within workout exercise
  Future<void> addSetToExercise(String workoutId, String exerciseId, {int targetReps = 10, double targetWeight = 0.0}) async {
    final workoutIndex = _workouts.indexWhere((w) => w.id == workoutId);
    if (workoutIndex != -1) {
      final exerciseIndex = _workouts[workoutIndex].exercises.indexWhere((e) => e.id == exerciseId);
      if (exerciseIndex != -1) {
        final exercise = _workouts[workoutIndex].exercises[exerciseIndex];
        // WorkoutExercise.addSet now takes targetReps, targetWeight
        final updatedExercise = exercise.addSet(targetReps: targetReps, targetWeight: targetWeight);
        
        await updateWorkoutExercise(workoutId, updatedExercise);
      }
    }
  }

  Future<void> removeSetFromExercise(String workoutId, String exerciseId, String setId) async {
    final workoutIndex = _workouts.indexWhere((w) => w.id == workoutId);
    if (workoutIndex != -1) {
      final exerciseIndex = _workouts[workoutIndex].exercises.indexWhere((e) => e.id == exerciseId);
      if (exerciseIndex != -1) {
        final exercise = _workouts[workoutIndex].exercises[exerciseIndex];
        final updatedExercise = exercise.removeSet(setId);
        
        await updateWorkoutExercise(workoutId, updatedExercise);
      }
    }
  }

  Future<void> updateSet(String workoutId, String exerciseId, String setId, {int? targetReps, double? targetWeight, String? type, int? targetRestSeconds}) async {
    final workoutIndex = _workouts.indexWhere((w) => w.id == workoutId);
    if (workoutIndex != -1) {
      final exerciseIndex = _workouts[workoutIndex].exercises.indexWhere((e) => e.id == exerciseId);
      if (exerciseIndex != -1) {
        final exercise = _workouts[workoutIndex].exercises[exerciseIndex];
        // WorkoutExercise.updateSet now takes targetReps, targetWeight, type, targetRestSeconds.
        // isCompleted is removed for template sets.
        final updatedExercise = exercise.updateSet(
          setId, 
          targetReps: targetReps, 
          targetWeight: targetWeight, 
          type: type, 
          targetRestSeconds: targetRestSeconds
        );
        
        await updateWorkoutExercise(workoutId, updatedExercise);
      }
    }
  }

  // Helper methods
  List<Workout> getWorkoutsInFolder(String? folderId) {
    return _workouts.where((w) => w.folderId == folderId).toList();
  }

  List<Workout> getWorkoutsNotInFolder() {
    return _workouts.where((w) => w.folderId == null).toList();
  }

  Workout? getWorkoutById(String id) {
    try {
      return _workouts.firstWhere((w) => w.id == id);
    } catch (e) {
      return null;
    }
  }

  WorkoutFolder? getFolderById(String id) {
    try {
      return _folders.firstWhere((f) => f.id == id);
    } catch (e) {
      return null;
    }
  }

  Future<void> clearUserWorkoutsAndFolders() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_workoutsKey);
    await prefs.remove(_foldersKey);
    _workouts = [];
    _folders = [];
    // No need to call saveData() as we are clearing.
  }
}
